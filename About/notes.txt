
设计模式 - 可复用面向对象软件的基础

Design Patterns  - Elements of Reuseable Object-Oriented Software

第一章 引言

1.1 什么是设计模式

一般而言，一个模式有四个基本要素：
1.模式名称（Pattern Name）
2.问题（Problem）
3.解决方案（Solution）
4.效果（Consuquences）

1.3 描述设计模式

模式名和分类
-模式名简洁地描述了模式的本质。
意图
-设计模式是做什么的？它的基本原理和意图是什么？它解决什么样的特定设计问题？
别名
-模式的其他名称
动机
-用以说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景。
适用性
-什么情况下可以使用该设计模式？该模式可用来改进哪些不良设计？你怎样识别这些情况？
结构
-采用基于对象建模技术的表示法对模式中的类进行图形描述。也使用交互图来说明对象之间的请求序列和协作关系。
参与者
-指设计模式中的类和/或对象以及它们各自的职责。
协作
-模式的参与者怎样协作以实现他们的职责。
效果
-模式怎样支持它的目标？使用模式的效果和所需做的权衡取舍？系统结构方面的那些方面可以独立改变？
实现
-实现模式时需要知道的一些提示、技术要点及应避免的缺陷，以及是否存在某些特定于实现语言的问题。
代码示例
-用来说明怎样用具体的语言实现该模式的代码片段。
已知应用
-实际系统中发现的模式的例子。
相关模式
-与这个模式紧密相关的模式有哪些？其间重要的不同之处是什么？这个模式应与哪些其他模式一起使用？

1.6 设计模式怎样解决问题

1.6.1 寻找合适的对象
面向对象程序由对象组成，对象包括数据和对数据进行操作的过程，过程通常称为方法或操作。对象在收到客户的请求（或消息）后，执行相应的操作。
客户请求时使对象执行操作的唯一方法，操作又是改变对象内部数据的唯一方法。由于这些限制，对象的内部状态是被封装的，它不能直接被访问，它的表示对于对象外部是不可见的。

1.6.2 决定对象粒度

1.6.3 指定对象接口
对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的型构（Signature）。对象操作所定义的所有操作型构的集合被称为该对象的接口（Interface）。对象接口描述了该对象所能接受的全部请求的集合，任何匹配对象接口中型构的请求都可以发送给该对象。
类型（Type）是用来标识特定接口的一个名字。如果一个对象接受_T接口所定义的所有操作请求，那么我们就说该对象具有_T类型。一个对象可以有许多类型，并且不同的对象可以共享同一个类型。对象接口的某部分可以用某个类型来刻画，而其他部分则可以用其他类型来刻画。当一个类型包含另一个类型的接口时，我们就说它是另一个类型的子类型（Subtype），另一个类型称之为它的超类型（Supertype）。我们常说子类型继承了它的超类型的接口。
当给对象发送请求时，所引起的具体操作既与请求本身有关又与接受对象有关。支持相同请求的不同对象可能对请求激发的操作有不同的实现。发送给对象的请求和它相应的操作在运行时刻的连接就称为动态绑定（Dynamic Binding）。
动态绑定是指发送的请求直到运行时刻才受你的具体的实现的约束。因为，在知道任何有正确接口的对象都将接受此请求时，你可以写一个一般的程序，它期待着那些具有该特定接口的对象。进一步讲，动态绑定允许你在运行时刻彼此替换有相同接口的对象。这种可替换行就称为多态（Polymorphism）。它是面向对象系统中的核心概念之一。多态允许客户对象仅要求其他对象支持特定接口，除此之外对其假设几近于无。多态简化了客户的定义，使得对象间彼此独立，并可以在运行时刻动态改变它们的相互的关系。

1.6.4 描述对象的实现
对象通过实例化类来创建，此对象称为该类的实例。当实例化类时，要给对象的内部数据（由实变量组成）来分配空间，并将操作与这些数据联系起来。对象的许多类似实例是由实例化同一个类来创建的。
抽象类（Abstract Class）的主要目的是为它的子类定义公共接口。一个抽象类将把它的部分接口或全部操作的实现延迟到子类中，因此，一个抽象类不能被实例化。在抽象类中定义却没有实现的操作被称为抽象操作（Abstract Operation）。非抽象类称为具体类（Concrete Class）。
子类能够改进和重新定义父类的操作。更具体的说，类能够重定义（override）父类定义的操作。重定义是的子类能够接管父类对请求的处理操作。类继承允许你只需简单的扩展其他类就可以定义新类，从而可以很容易地定义具有相近功能的对象族。
混入类（Mixin Class）是给其他类提供可选择的接口或功能的类。它与抽象类一样不能实例化。混入类要求多继承。

a 类继承与接口继承的比较
理解对象的类（Class）与对象的类型（Type）之间的差别非常重要。
一个对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的状态。但是对象的类型只与它的接口有关，接口即对象能响应的请求的集合。一个对象可以有多个类型，不同的对象可以有相同的类型。
C++的类既指定对象的类型又指定对象的实现。发送消息时需要检查消息接受者是否实现了该消息，但不检查接收者是否是某个特定类的实例。
理解类继承和接口继承之间的差别也十分重要。类继承根据一个对象的实现定义了另一个对象的实现。简而言之，它是代码和表示的共享机制。然而，接口继承描述了一个对象什么时候能被用来替代另一个对象。
在C++中，继承既指接口的继承又指实现的继承。C++中接口继承的标准方法是共有继承一个含虚成员函数的类。C++中纯接口继承接近于公有继承纯抽象类，纯实现继承或纯类继承接近于私有继承。

b 对接口编程，而不是对实现编程
类继承是一个通过复用父类功能而扩展应用功能的基本机制。它允许你根据旧对象快速定义新对象。它允许你从已存在的类中继承所需要的绝大部分功能，从而无需任何代价就可以获得新的实现。
然而，实现的复用只是成功的一半，继承所拥有的定义具有相同接口的对象族的能力也是很重要的。
当继承被恰当使用时，所有从抽象类导出的类将共享该抽象类的接口。这意味着子类仅仅添加或重定义操作，而没有隐藏父类的操作。这时，所有的子类都能响应抽象类接口中的请求，从而子类的类型都是抽象类的子类型。
只根据抽象类中定义的接口来操纵对象有以下两个好处：
-客户无须知道他们使用对象的具体类型，只须对象有客户所期望的接口。
-客户无须知道他们使用的对象是用什么类来实现的，他们只须知道定义接口的抽象类。
这将极大地减少子系统实现之间的相互依存关系，也产生了可复用的面向接口设计的如下原则：
-针对接口编程，而不是针对实现编程。
不将变量声明为某个特定的具体类的实例对象，而是让它遵从抽象类所定义的接口。

1.6.5 运用复用机制

a 继承和组合的比较

面向对象系统中功能复用的两种最常用技术是类继承和对象组合（Object Composition）。类继承允许你根据其他类的实现来定义一个类的实现。这种通过生成子类的复用机制通常被称为白箱复用（White-Box Reuse）。术语“白箱”是相对可视性而言：在继承方式中，父类的内部细节子类可见。
对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用（Black-Box Reuse），因为对象的内部细节是不可见的。
类继承是在编译时刻静态定义的，且可直接使用，因为程序设计语言直接支持类继承。类继承可以方便地改变被复用的实现。当一个子类重定义一些而不是全部的操作时，它也能影响它所继承的操作，只要在这些操作中调用了被重定义的操作。
类继成的不足之处包括：无法在运行时刻改变从父类继承的实现；由于父类通常定义了部分子类的具体表示，而继承对子类揭示了其父类实现的细节，所以继承通常被认为是破坏了封装性。子类中的实现与它的父类有如此紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。
当你需要复用子类是，实现上的依赖性就会产生问题。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。一个可用的解决办法就是只继承抽象类，因为抽象类通常提供较少的实现。
对象组合是通过获得对其他其他对象的引用而在运行时刻动态定义的。组合要求对象遵守彼此的接口约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和其他对象一起使用。这还会产生良好的结果：因为对象只能通过接口访问，所以我们并不破坏封装性。只要实现一致，运行时刻还可以用一个对象来替代另一个对象；更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系。
对象组合对系统设计还有另一个作用，即优先使用对象组合有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持在较小的规模，并且不太可能增长为不可控制的庞然大物。另一方面，介于对象组合的设计会有更多的对象（而有较少的类），且系统的行为将依赖于对象间的关系而不是被定义在某个类中。
这到处了我们使用面向对象设计的第二个原则：
优先使用对象组合，而不是类继承。
理想情况下，你不应为获得复用而去创建新的构件。你应该能够只使用对象组合技术，通过组装已有的构件就能获得你需要的功能。

b 委托

委托（Delegation）是一种组合方法，它使组合具有与继承同样的复用能力。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给他的代理者（Delegate）。这类似与子类将请求教给它的父类处理。使用继承时，被继承的操作总能引用接受请求的对象，C++中通过this成员变量。委托方式为了得到同样的效果，接受请求的对象将自己传给被委托者（代理人），使被委托的操作可以引用接受请求的对象。
距离来说，我们可以在窗口类中保存一个矩形类的实例变量来代理矩形类的特定操作，这样窗口类可以复用矩形类的操作，而不必像继承时那样定义成矩形类的子类。也就是说，一个窗口拥有一个矩形，而不是一个窗口就是一个矩形。窗口现在必须显式的将请求转发给它的矩形实例，而不是像以前那样它必须继承矩形的操作。

class Rectangle
{
public:
	double Area() {return m_dWidth * m_dHeight;}
private:
	double m_dWidth;
	double m_dHeight;
}

class Window
{
public:
	double Area() {return m_Rect.Area();}
private:
	Rectangle m_Rect;
}

委托的主要优点在于它便于运行时刻组合对象操作以及改变这些操作的组合方式。假定矩形对象和圆对象有相同的类型，我们只需简单的用圆对象替换矩形对象，则得到的窗口就是圆形的。
委托与哪些通过对象组合以取得软件灵活性的技术一样，具有如下不足之处：动态的、高度参数化的软件比静态软件更难于理解。还有运行低效问题，不过从长远来看人的低效才是更主要的。只有当委托使设计比较简单而不是更复杂时，它才是好的选择。
委托是对象组合的特例。它告诉你对象组合作为一个代码复用机制可以替代继承。

c 继承和参数化类型的比较

另一种功能复用技术（并非严格的面向对象技术）是参数化类型（Parameterized Type），也就是类属（Generic）或模板（Template）。它允许你在定义一个类型时并不指定该类型所用到的其他所有类型。未经指定的类型在使用时以参数形式提供。

1.6.7 设计应支持变化

获得最大限度复用的关键在于对新需求和已有需求发生变化时的预见性，要求你的系统设计要能够相应地改进。
为了设计适应这种变化、且具有健壮性的系统，你必须考虑系统在它的声明周期内会发生怎样的变化。一个不考虑系统变化的设计在将来就有可能需要重新设计。这些变化可能时类的重新定义和实现，修改客户和重新测试。重新设计会影响软件系统的许多仿麦呢，并且未曾料到的变化总是代价巨大的。

一些导致重新设计的一般原因：

-通过显式地指定一个类来创建对象。在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象。
-对特殊操作的依赖。当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把代码写死，你将可以在编译时刻或运行时刻很方便地改变相应请求的方法。
-对硬件和软件平台的依赖。外部的操作系统接口和应用编程接口在不同的软硬件平台上是不同的。依赖与特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平台的更新。
-对对象表示或实现的依赖。知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。
-算法依赖。算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。
-紧耦合。紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体。松散耦合提高了一个类半身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。
-通过生成子类来扩充功能。通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销。定义子类还需要对父类有深入的了解。一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通过以新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中去。零一方面，过多使用对象组合会使设计难于理解。许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例及逆行组合来引入定制的功能。
-不能方便地对类进行修改。又是你不得不改变一个难以修改的类。也许你需要源代码而又没有，或者可能对类的任何改变会要求修改许多已存在的其他子类。

设计模式在开发如下三类主要软件中所起的作用：

-应用程序
如果你将要建造像文档编辑器或电子制表软件这样的应用程序（Application Program），那么它的内部复用性、可维护性和可扩展性是要优先考虑的。内部复用性确保你不会做多余的设计和实现。设计模式通过减少依赖性来提高内部复用性。松散耦合也增强了一类对象与其他多个对象协作的可能性。例如，通过鼓励和封装每一个操作，以消除对特定操作的依赖，可使在不同上下文中复用一个操作变得更加简单。消除对算法和表示的依赖性可达到同样的效果。
-工具箱
-框架

1.7 怎样选择设计模式
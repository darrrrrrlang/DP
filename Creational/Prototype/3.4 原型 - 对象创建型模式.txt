1.意图
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

2.动机

3.适用性
当一个系统应该独立与它的产品创建、构成和表示时，要使用Prototype模式；以及
- 当要实例化的类是在运行时刻指定时，例如通过动态装载；或者
- 为了避免创建一个与产品类层次平行的工厂类层次时；或者
- 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类方便一些。

4.结构
见类图

5.参与者
Prototype
- 声明一个克隆自身的接口
ConcretePrototpye
- 实现一个克隆自身的操作
Client
- 让一个原型克隆自身从而创建一个新的对象

6.协作
客户请求一个原型克隆自身

7.效果
Prototype有许多和AbstractFactory和Builder一样的效果：它对客户隐藏了具体的产品类，因此减少了客户知道的名字数目。此外这些模式使客户无需改变即可使用与特定应用相关的类。
以下是Prototype模式的另外一些有点：
- 运行时刻增加和删除产品
- 改变值以指定新对象
- 改变结构以指定新对象
- 减少了子类的构造
- 用类动态配置应用

8.实现
在像C++这样的语言中，类不是对象，并且运行时刻只能得到很少或者得不到任何类型信息，所以Prototype特别有用。当实现原型时，要考虑下面一些问题：
- 使用一个原型管理器。当一个系统中原型数目不固定时，要保持一个可用原型的注册表。客户不会自己来管理原型，但会在注册表中存储和检索原型。客户在克隆一个原型前会向注册表请求该原型。我们称这个注册表为原型管理器（Prototype Manager）。
- 实现克隆操作。Prototype模式最困难的部分在于正确实现Clone操作。当对象结构包含循环引用时，这尤为棘手。
- 初始化克隆对象。当一些客户对克隆对象已经相当满意时，另一些客户将会希望使用他们选择的一些值来初始化该对象的一些或是所有的内部状态。

9.代码示例

10.已知应用

11.相关模式
Protype和AbstractFactory在某种方面是类似的。但是它们也可以一起使用。AbstractFactory可以存储一个被克隆的原型集合，并且返回产品对象。